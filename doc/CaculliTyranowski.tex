\documentclass[10pt]{article}

\usepackage{amsmath}
\usepackage[french, onelanguage]{algorithm2e}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{glossaries}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{tabularx}
\usepackage{tikz}
\usepackage{tocloft}
\usepackage{verbatim}
\usepackage{xcolor}

\makeglossaries

\newacronym{ansi}{ANSI}{American National Standard Institute}
\newacronym{ram}{RAM}{Random Access Memory}

\usetikzlibrary{calc, shapes.multipart, chains, arrows}

\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}

\definecolor{RoyalBlue}{cmyk}{1, 0.50, 0, 0}

\lstset{language=C,
  keywordstyle=\color{RoyalBlue},
  basicstyle=\scriptsize\ttfamily,
  commentstyle=\ttfamily\itshape\color{darkgray},
  stringstyle=\ttfamily,
  breaklines=true,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=4,
  autogobble=true
}

\title{Documentation Mini Projet Langage C}
\author{Caculli Giorgio, Jedrzej Tyranowski\\Haute École de Louvain en Hainaut (HELHa)}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
  Documentation pour le projet de Langage procédural sur les listes chaînées. Projet basé sur le concept
  d'un centre de formations.
\end{abstract}
%\small
\textbf{\textit{Mots-clés : }}liste, chaînée, c, noeud, centre, formation, tête

\newpage
\tableofcontents

\newpage
\section{Introduction}

\subsection{Le langage C}
La langage de programmation utilisé lors du développement et la mise en \oe{}uvre du programme est le
\texttt{ANSI-C}. Les différentes versions du langage disponibles lors du développement de ce programme sont:
\begin{itemize}
\item \textbf{ANSI-C} : La première vérsion standardisée par le \textbf{\acrlong{ansi}},
  abrégé en \textbf{\acrshort{ansi}} dans ce document, du langage \texttt{C} publiée en 1990.
\item \textbf{C-99} : Révision de la version \acrshort{ansi} pour permettre aux développeurs d'utiliser les
  commentaires \texttt{//}, les booléans grâce à la librairie \texttt{<stdbool.h>}, la déclaration des int
  directement dans la boucle \texttt{for}, et d'autres modérnisations de la syntaxe.
\item \textbf{C-11} : Mise à jour du langage \texttt{C} pour permettre le support des \texttt{thread} afin de pouvoir faire du multi-threading.
\item \textbf{C-17} : Révision de la version \textbf{C-11} qui n'ajoute aucune nouvelle fonctionnalité, mais
  corriges beaucoup bugs présents dans la version 11.
\end{itemize}
Dans les différentes applications que l'on a fait dans le cours de Langage procédural, la plupart des
interactions que l'on a eu avec le langage \texttt{C}, notammente le fait de devoir déclarer un \texttt{int}
avant une boucle \texttt{for}, ressemblaient fortement à l'\acrshort{ansi}-\texttt{C}. C'est pourquoi nous
avons choisi d'utiliser cette vérsion là.

\subsection{Fonctions générales utilisées}
Différentes fonctions ont été utilisée lors du développement de ce programme, ainsi que des MACRO pour
permettre au compilateur de reconnaître le système d'exploitation dans lequel le logiciel compilé tournera.
Voici une liste des fonctions clés utilisées:
\begin{itemize}
  
\item \texttt{fopen()} : Fonction qui sert à ouvrir un flux, plus précisement, un fichier.\\
  Exemple :
  \begin{lstlisting}
    /* Admettons que le fichier donnees.dat existe */
    #include <stdio.h>
    int main() {
      FILE *fichier_in = fopen( "donnees.dat", "r" );
      /* On ouvre le fichier donnees.dat en lecture */
      FILE *fichier_out = fopen( "resultats.txt", "w" );
      /* Si le fichier resultats.txt n'existe pas on le cree, s'il existe toute information presente est ecrasee, puis on y accede en ecrite */
      return 0;
    }
  \end{lstlisting}

\item \texttt{fclose()} : Fonction qui sert à fermer tout flux ouvert.\\
  Exemple :
  \begin{lstlisting}
    /* Admettons que le fichier donnees.dat existe */
    #include <stdio.h>
    int main() {
      FILE *fichier_in = fopen( "donnees.dat", "r" );
      /* On ouvre le fichier donnees.dat en lecture */
      FILE *fichier_out = fopen( "resultats.txt", "w" );
      /* Si le fichier resultats.txt n'existe pas on le cree, s'il existe toute information presente est ecrasee, puis on y accede en ecrite */
      fclose( fichier_out );
      fclose( fichier_in );
      /* On ferme les fichiers lorsqu'on doit plus travailler avec eux */
      return 0;
    }
  \end{lstlisting}

  
\item \texttt{printf()} : Fonction qui sert à afficher une châine de caractères dans la console.\\
  Exemple:
  \begin{lstlisting}
    #include <stdio.h>
    int main() {
      printf( "Hello World!\n" ); /* Affiche "Hello World!" dans la console */
      return 0;
    }
  \end{lstlisting}
  
\item \texttt{fprintf()} : Fonction qui sert à écrire une chaîne de caractères vers un flux spécifique.\\
  Exemple:
  \begin{lstlisting}
    #include <stdio.h>
    int main() {
      File *ficher_sortie = fopen( "fichier_sortie.txt", "w" );
      /* On cree et on ouvre un fichier nomme fichier_sortie.txt en ecriture */
      fprintf( ficher_sortie, "Hello World!\n" );
      /* Ecrit "Hello World!" dans le ficher fichier_sortie.txt mais pas dans la console */
      fprintf( stdout, "Hello World!\n" );
      /* Affiche "Hello World!" dans la console mais pas dans le fichier de sortie */
      return 0;
    }
  \end{lstlisting}

\item \texttt{scanf()} : Fonction qui sert à extrapoler une entrée du clavier et stocker les informations extrapolées dans les paramètres déclarés dans la fonction.\\
  Exemple:
  \begin{lstlisting}
    #include <stdio.h>
    int main() {
      char prenom[50];
      int age;
      printf( "Comment t'appels-tu ? " );
      scanf( "%s", prenom ); /* Admettons que l'utilisateur insere "Jedrzej" */
      printf( "Quel age as-tu %s ? ", prenom );
      scanf( "%d", &age ); /* Admettons que l'utilisateur insere "21" */
      printf( "Salut %s, je vois que tu as %d ans!\n", prenom, age );
      /* Affiche "Salut Jedrzej, je vois que tu as 21 ans!" dans la console */
      return 0;
    }
  \end{lstlisting}
  
\item \texttt{fscanf()} : Fonction qui sert à extrapoler des entrées à partir d'un flux spécifique en respectant une structure précise, et stocker les informations extrapolées dans des paramètres déclarés dans la fonction.\\
  Exemple:
  \begin{lstlisting}
    /* Contenu dans ficher_entree.txt */
    /* Jedrzej 21 */
    #include <stdio.h>
    int main() {
      char prenom[50];
      int age;
      FILE *ficher_in = fopen( "fichier_entree.txt", "r" );
      /* On ouvre un fichier nomme fichier_entree.txt en lecture */
      fscanf( fichier_in, "%s %d\n", prenom, &age );
      /* On lit le contenu de fichier_entree.txt */
      printf( "Salut %s, je vois que tu as %d ans\n", prenom, age );
      /* Affiche "Salut Jedrzej, je vois que tu as 21 ans!" dans la console */
      return 0;
    }
  \end{lstlisting}
  
\item \texttt{fgets()} : Fonction qui a le même principe que fscanf, mais garde les espaces.\\
  Exemble :
  \begin{lstlisting}
    /* Contenu dans fichier_entree.txt */
    /* Caculli Giorgio 23 */
    #include <stdio.h>
    int main() {
      char nom_prenom[15];
      int age;
      FILE *fichier_in = fopen( "fichier_entree.txt", "r" );
      fgets( nom_prenom, 16, fichier_in );
      /* Lit les 15 caracteres depuis le fichier de donnees fichier_entree.txt */
      fscanf( fichier_in, "%d", &age );
      /* Lit l'age depuis le fichier de donnees fichier_entree.txt */
      printf( "%s %d\n", nom_prenom, age );
      /* Affiche "Caculli Giorgio 23" dans la console */
      return 0;
    }
  \end{lstlisting}
  
\item \texttt{strcpy()} : Fonction qui sert à copier une chaîne de caractères vers une autres chaîne de caractères.\\
  Exemple :
  \begin{lstlisting}
    #include <stdio.h>
    #include <string.h>
    int main() {
      char prenom[10];
      char source[10] = "Giorgio";
      strcpy( prenom, source );
      printf( "%s\n", prenom ); /* Affiche "Giorgio" dans la console */
      return 0;
    }
  \end{lstlisting}
  
\item \texttt{sizeof()} : Fonction qui renvoie la quantité de mémoire (en bytes) qu'une entité va occuper dans la \acrlong{ram}, ou mémoire vive en français, abrégé en \acrshort{ram} dans ce document.\\
  Exemple :
  \begin{lstlisting}
    #include <stdio.h>
    int main() {
      printf( "Taille de char: %lu\n", sizeof( char ) );
      /* Affiche 1 dans la console */
      printf( "Taille de int: %lu\n", sizeof( int ) );
      /* Affiche 4 dans la console */
      printf( "Taille de long: %lu\n", sizeof( long ) );
      /* Affiche 8 dans la console */
      printf( "Taille de int[4]: %lu\n", sizeof( int[4] ) );
      /* Affiche 16 dans la console, soit 4*4=16 */
      return 0;
    }
  \end{lstlisting}

\item \texttt{memcpy()} : Fonction qui copiés n octets depuis une zone mémoire vers une autre zone mémoire.\\
  Exemple :
  \begin{lstlisting}
    #include <stdio.h>
    #include <string.h>
    int main() {
      int src[] = {1, 2, 3};
      size_t n = sizeof(src) / sizeof(src[0])
      /* En sachant que la taille d'un int = 4 bytes, et qu'il y a 3 int dans src, on obtient 4 * 3 = 12 bytes utilises. On divise la taille totale du vecteur, soit 12, par la taille du premier element du vecteur, soit 4, donc 12 / 4 = 3 elements dans le vecteur */
      int dest[n]; /* On initialiser le vecteur dest avec la meme taille de src, ici 3 */
      memcpy( dest, src, sizeof(dest) ); /* On copie les informations de src vers dest */
      int i;
      for( i = 0; i < n; i++ ) {
        /* On parcourt tous les elements dans dest, du premier (indice 0) jusqu'au troisieme (indide 2) */
        printf( "%d ", dest[i] ); /* Affiche 1 2 3 dans la console */
      }
      return 0;
    }
  \end{lstlisting}
  
\item \texttt{getchar()} : Fonction qui sert à lire un caractère depuis un flux.\\
  Exemple:
  \begin{lstlisting}
    #include <stdio.h>
    int main() {
      char lettre;
      printf( "Inserez une lettre: " ); /* Admettons que l'utilisateur insere "a" */
      char c = getchar();
      printf( "Lettre inseree : %c\n", c );
      /* Affiche "a" dans la console */
    }
  \end{lstlisting}

\item \texttt{system()} : Fonction qui permet de lancer l'execution d'une commande sur le système d'exploitation hôte.\\
  Exemple:
  \begin{lstlisting}
    #include <stdlib.h>
    int main() {
      char *commande = "dir";
      system( commande );
      /* Execute la commande "dir", fonction qui sert a afficher ce qui est present dans le repertoire */
      return 0;
    }
  \end{lstlisting}

\item \texttt{calloc()} : Fonction qui permet de faire de l'allocation dynamique de mémoire.\\
  Exemple:
  \begin{lstlisting}
    #include <stdio.h>
    #include <stdlib.h>
    int main() {
      int *pointer;
      int i, n;
      printf( "Nombres d'elements a ajouter: " );
      scanf( "%d", &n ); /* Admettons que l'utilisateur insere 3 */
      pointer = ( int * ) calloc( n, sizeof( int ) );
      for( i = 0; i < n; i++ )
      {
        printf( "Entrez le numero N.%d ", i + 1 );
        scanf( "%d", &pointer[i] ); /* Admettons que l'utilisateur insere 1 2 et 3 */
      }
      for( i = 0; i < n; i++ )
      {
        printf( "%d ", pointer[i] );
        /* Affiche 1 2 3 dans la console */
      }
      return 0;
    }
  \end{lstlisting}
  
\end{itemize}

\subsubsection{Qu'est-ce l'allocation dynamique de mémoire?}
Une allocation dynamique de mémoire est le processus d'alluer de la mémoire lors de l'exécution d'un programme. Il existe quatre fonctions en \texttt{C} qui peuvent être utilisée pour allouer et libérer de la mémoire: \texttt{calloc()}, \texttt{free()}, \texttt{realloc()} et \texttt{malloc()}. Ces fonctions sont accéssible lors de l'introduction du header \texttt{<stdlib.h>} dans le code.

\subsubsection{Qu'est-ce \texttt{calloc()} ?}
\texttt{calloc()} est une fonction qui renvoie un pointeur vers un espace mémoire suffisamment libre pour stocker un tableau au nombre d'objets indéterminé et à la taille spécifiée. Si c'est pas le cas, la fonction renverra \texttt{NULL}. Le stockage est initialisé à zéro.

\subsubsection{Qu'est-ce \texttt{malloc()} ?}
\texttt{malloc()} est une fonction qui renvoie un pointeur vers un espace mémoire non initialisé. Si l'allocation n'est pas possible, la fonction renverra \texttt{NULL}. Si l'espace affecté par l'allocation est saturé, les résultats ne seront pas définis.

\subsubsection{Différences entre \texttt{calloc()} et \texttt{malloc()}}
\begin{center}
  \begin{tabularx}{\textwidth}{| >{\centering\arraybackslash}X | >{\centering\arraybackslash}X |}
    \hline
    \textbf{\texttt{malloc()}} & \textbf{\texttt{calloc()}} \\ 
    \hline
    \texttt{void * malloc( size\_t n );} & \texttt{void * calloc( size\_t n, size\_t size );} \\
    \hline
    \texttt{malloc()} prend un argument (le nombre d'octets)  & \texttt{calloc()} prend deux arguments (le nombre de blocs et la taille de chaque bloc)  \\
    \hline
    \texttt{malloc()} est plus rapide que \texttt{calloc()} & \texttt{calloc()} prends plus de temps que \texttt{malloc()} car la mémoire doit être initialisée à zéro \\
    \hline
  \end{tabularx}
\end{center}

\newpage
\section{Listes chaînées}
\begin{tikzpicture}[list/.style={
      rectangle split,
      rectangle split parts=2,
      draw,
      rectangle split horizontal
    },
    >=stealth,
    start chain]

  \node[list,on chain] (A) {12};
  \node[list,on chain] (B) {99};
  \node[list,on chain] (C) {37};
  \node[on chain,draw,inner sep=6pt] (D) {};
  \draw (D.north east) -- (D.south west);
  \draw (D.north west) -- (D.south east);
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
\end{tikzpicture}

\subsection{Création d'un nouveau n\oe{}ud}
\subsection{Insertion d'un n\oe{}ud dans une liste chaînée}
\subsection{Suppression d'un n\oe{}ud d'une liste chaînée}
\subsection{Affichage d'une liste chaînée}

\newpage
\section{Énoncé}

\newpage
\section{Programme}
\subsection{Mode d'emploi}

\newpage
\section{Code}
\subsection{Structures}
Voici les différentes structures qui ont été utilisée dans la conception du programme:

\begin{lstlisting}[firstnumber=30]
  typedef struct personne
  {
    int id;
    char nom[25];
    char prenom[25];
    int formateur;
    int nb_formations;
    int formations[30];
    int nb_jours_indisponible;
    int jours_indisponible[7];
    int reduction;
    int val_reduction;
  } personne;
\end{lstlisting}

Cette structure sert à stocker les informations qui composent une personne quelconque: étudiant ou formateur.\\
Voici ce que représente chaque partie de la structure:
\begin{itemize}
\item \texttt{int id} : L'identifiant unique de la personne.
\item \texttt{char nom[25]} : Le nom de la personne (25 caractères maximum).
\item \texttt{char prenom[25]} : Le prénom de la personne (25 caractères maximum).
\item \texttt{int formateur} : 1 si la personne est un formateur, 0 si la personne est un étudiant.
\item \texttt{int nb\_formations} : Le nombre de formations auquel la personne participera.
\item \texttt{int formations[30]} : Vecteur qui stockera les idéntifiants des différentes formations auquel la personne participera (On suppose dans une année, une personne ne peut participer qu'à 30 formations maximum).
\item \texttt{int nb\_jours\_indisponible} : Si la personne est un formateur, il se peut qu'il/elle ait des jours d'indisponibilé, cette variable va stocker le nombre de jours où cette personne est indisponile (maximum 7).
\item \texttt{int jours\_indisponibles[7]} : Le vecteur qui stockera les jours auquel le formateur ne sera pas disponible(1 - lundi, 2 - mardi, etc\ldots).
\item \texttt{int reduction} : Si la personne est un étudiant, il se peut qu'il ait une réduction sur son minérval, 1 s'il a droit à une réduction, 0 si pas.
\item \texttt{int val\_reduction} : Le pourcentage de réduction auquel un étudiant à droit.
\end{itemize}

\begin{lstlisting}[firstnumber=51]
  typedef struct noeud_db_personne
  {
    personne *p;
    struct noeud_db_personne *next;
  } noeud_db_personne;
\end{lstlisting}

Cette structure sert à devenir les différents n\oe{}uds qui seront stockés dans la base de donnée, soit la structure \texttt{db\_personne}.
Voici ce qui représent chaque partie de la structure:
\begin{itemize}
\item \texttt{personne *p} : Le pointeur de la personne qui sera stocké dans ce n\oe{}ud lors de sa création.
\item \texttt{struct noeud\_db\_personne *next} : qui contiendra le tête lors qu'on créera un nouveau n\oe{}ud, sinon \texttt{NULL}.
\end{itemize}

\begin{lstlisting}[firstnumber=63]
  typedef struct db_personne
  {
    noeud_db_personne *head;
  } db_personne;
\end{lstlisting}

Cette structure sert à contenir tous les différentes n\oe{}uds \texttt{noeud\_db\_personne}. C'est à partir de cette structure que l'on stockera les différentes n\oe{}uds qui eux-mêmes stockeront leurs personnes respectives.
\begin{itemize}
\item \texttt{noeud\_db\_personne *head} : La tête de la liste chaînée qui stockera toutes les personnes.
\end{itemize}

\begin{lstlisting}[firstnumber=73]
  typedef struct noeud_formation
  {
    personne *p;
    struct noeud_formation *next;
  } noeud_formation;
\end{lstlisting}

Cette structure va stocker les différentes personnes qui participeront à une formation spécifique.
\begin{itemize}
\item \texttt{personne *p} : La personne qui participera à la formation.
\item \texttt{struct noeud\_formation *next} : Le n\oe{}ud de pour la prochaine personne qui sera stockée.
\end{itemize}

\begin{lstlisting}[firstnumber=94]
  typedef struct formation
  {
    int id;
    char nom[40];
    float prix;
    int nb_jours;
    int jours[7];
    float heures[24];
    float durees[10];
    int nb_prerequis;
    int prerequis[10];
    noeud_formation *head;
  } formation;
\end{lstlisting}

Cette structure sert à stocker toutes les informations qui composent une formations.
Voici ce que chaque partie représente:
\begin{itemize}
\item \texttt{int id} : L'identifiant unique de la formation.
\item \texttt{char nom[40]} : Le nom de la formation (40 caractères maximum).
\item \texttt{float prix} : Le coût de la formation.
\item \texttt{int nb\_jours} : Le nombre de jours par semaine où cette formation à cours.
\item \texttt{int jours[7]} : Vecteur contenant les jours où la formation a cours.
\item \texttt{float heures[24]} : Le nombre d'heures du début de la formation.
\item \texttt{float durees[10]} : Les différentes durées du cours lors de la semaine.
\item \texttt{int nb\_prerequis} : Le nombre de prérequis pour avoir accès à cette formation.
\item \texttt{int prerequis[10]} : Vecteur contenant les identifiants des formations qui seraient des prérequis.
\item \texttt{noeud\_formation *head} : Étant donné qu'une formation stocke des personnes, elle-même est une liste chaînée qui stockera un nombre indéterminé de participants.
\end{itemize}

\begin{lstlisting}
  typedef struct noeud_db_formation
  {
    formation *f;
    struct noeud_db_formation *next;
  } noeud_db_formation;
\end{lstlisting}

\begin{lstlisting}
  typedef struct db_formation
  {
    noeud_db_formation *head;
  } db_formation;
\end{lstlisting}

\newpage
\subsection{Fonctions}

\begin{lstlisting}
  personne *creer_personne( char nom[], char prenom[], int formateur );
\end{lstlisting}

\begin{lstlisting}
  void afficher_personne( personne *p );
\end{lstlisting}

\begin{lstlisting}
  db_personne *creer_db_personne();
\end{lstlisting}

\begin{lstlisting}
  void ajouter_db_personne( db_personne *db, personne *p );
\end{lstlisting}

\begin{lstlisting}
  int supprimer_db_personne( db_personne *dbp, int id );
\end{lstlisting}

\begin{lstlisting}
  void afficher_db_personne( db_personne *db );
\end{lstlisting}

\begin{lstlisting}
  personne *get_personne( db_personne *db, char nom[], char prenom[], int formateur );
\end{lstlisting}

\begin{lstlisting}
  formation *creer_formation( char nom[], float prix );
\end{lstlisting}

\begin{lstlisting}
  int ajouter_formation( formation *f, personne *p );
\end{lstlisting}

\begin{lstlisting}
  int supprimer_personne_de_formation( formation *f, int id );
\end{lstlisting}

\begin{lstlisting}
  void afficher_formation( formation *f );
\end{lstlisting}

\begin{lstlisting}
  db_formation *creer_db_formation();
\end{lstlisting}

\begin{lstlisting}
  void ajouter_db_formation( db_formation *db, formation *f );
\end{lstlisting}

\begin{lstlisting}
  int supprimer_db_formation( db_formation *dbf, int id );
\end{lstlisting}

\begin{lstlisting}
  formation *get_formation( db_formation *dbf, char nom_formation[] );
\end{lstlisting}

\begin{lstlisting}
  void afficher_db_formation( db_formation *dbf );
\end{lstlisting}

\begin{lstlisting}
  void menu_creer_formation( db_formation *f );
\end{lstlisting}

\begin{lstlisting}
  void menu_creer_personne( db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  int menu_creer( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  void menu_ajouter_formation( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  void menu_supprimer_personne( db_formation *dbf, db_personne *dbp );
\end{lstlisting}

\begin{lstlisting}
  void menu_supprimer_formation( db_formation *dbf, db_personne *dbp );
\end{lstlisting}

\begin{lstlisting}
  int menu_supprimer_personne_de_formation( db_formation *dbf );
\end{lstlisting}

\begin{lstlisting}
  int menu_supprimer( db_formation *dbf, db_personne *dbp );
\end{lstlisting}

\begin{lstlisting}
  int menu_affichage( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  int menu( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  int main( void );
\end{lstlisting}

\newpage
\printglossary

\end{document}
