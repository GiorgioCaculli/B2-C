\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage[french, onelanguage]{algorithm2e}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{glossaries}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{tikz}
\usepackage{tocloft}
\usepackage{verbatim}
\usepackage{xcolor}

\makeglossaries

\newacronym{ansi}{ANSI}{American National Standard Institute}

\usetikzlibrary{calc, shapes.multipart, chains, arrows}

\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}

\definecolor{RoyalBlue}{cmyk}{1, 0.50, 0, 0}

\lstset{language=C,
  keywordstyle=\color{RoyalBlue},
  basicstyle=\scriptsize\ttfamily,
  commentstyle=\ttfamily\itshape\color{gray},
  stringstyle=\ttfamily,
  breaklines=true,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=4,
  autogobble=true
}

\title{Documentation Mini Projet Langage C}
\author{Caculli Giorgio, Jedrzej Tyranowski\\Haute École de Louvain en Hainaut (HELHa)}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
  Documentation pour le projet de Langage procédural sur les listes chaînées. Projet basé sur le concept
  d'un centre de formations.
\end{abstract}
%\small
\textbf{\textit{Mots-clés : }}liste, chaînée, c, noeud, centre, formation, tête

\newpage
\tableofcontents

\newpage
\section{Introduction}

\subsection{Le langage C}
La langage de programmation utilisé lors du développement et la mise en \oe{}uvre du programme est le
\texttt{ANSI-C}. Les différentes versions du langage disponibles lors du développement de ce programme sont:
\begin{itemize}
\item \textbf{ANSI-C} : La première vérsion standardisée par le \textbf{\acrlong{ansi}},
  abrégé en \textbf{\acrshort{ansi}} dans ce document, du langage \texttt{C} publiée en 1990.
\item \textbf{C-99} : Révision de la version \acrshort{ansi} pour permettre aux développeurs d'utiliser les
  commentaires \texttt{//}, les booléans grâce à la librairie \texttt{<stdbool.h>}, la déclaration des int
  directement dans la boucle \texttt{for}, et d'autres modérnisations de la syntaxe.
\item \textbf{C-11} : Mise à jour du langage \texttt{C} pour permettre le support des \texttt{thread} afin de pouvoir faire du multi-threading.
\item \textbf{C-17} : Révision de la version \textbf{C-11} qui n'ajoute aucune nouvelle fonctionnalité, mais
  corriges beaucoup bugs présents dans la version 11.
\end{itemize}
Dans les différentes applications que l'on a fait dans le cours de Langage procédural, la plupart des
interactions que l'on a eu avec le langage \texttt{C}, notammente le fait de devoir déclarer un \texttt{int}
avant une boucle \texttt{for}, ressemblaient fortement à l'\acrshort{ansi}-\texttt{C}. C'est pourquoi nous
avons choisi d'utiliser cette vérsion là.

\subsection{Fonctions générales utilisées}
Différentes fonctions ont été utilisée lors du développement de ce programme, ainsi que des macros pour
permettre au compilateur de reconnaître le système d'exploitation dans lequel le logiciel compilé tournera.
Voici une liste des fonctions clés utilisées:
\begin{itemize}
\item \texttt{strcpy()} : Fonction qui prend en paramètre un \texttt{char dest[]} et un
  \texttt{char src[]}, soit la destination dans laquelle on souhaite stocker la chaîne de caractères, et la
  source par laquelle le compilateur va reprende la chaîne de caractères.\\
  Exemple:
  \begin{lstlisting}
    #include <stdio.h>
    #include <string.h>
    int main() {
      char prenom[10];
      char source[10] = "Giorgio";
      strcpy( prenom, source );
      printf( "%s\n", prenom ); /* Affichera "Giorgio" dans la console */
    }
  \end{lstlisting}

\item \texttt{memcpy()}
\item \texttt{printf()}
\item \texttt{fprintf()}
\item \texttt{scanf()}
\item \texttt{fscanf()}
\item \texttt{fgets()}
\item \texttt{fopen()}
\item \texttt{fclose()}
\item \texttt{calloc()}
\item \texttt{getchar()}
\item \texttt{system()}
\end{itemize}

\subsubsection{Qu'est-ce l'allocation de mémoire dynamique?}
\subsubsection{Qu'est-ce \texttt{malloc()} ?}
\subsubsection{Qu'est-ce \texttt{calloc()} ?}
\subsubsection{Pourquoi utiliser \texttt{calloc()} ?}
\subsubsection{Pourquoi utiliser \texttt{malloc()} ?}
\subsubsection{Syntaxe de \texttt{calloc()}}
\subsubsection{Exemples de \texttt{calloc()}}
\subsubsection{Syntaxe de \texttt{malloc()}}
\subsubsection{Exemples de \texttt{malloc()}}
\subsubsection{Différences entre \texttt{calloc()} et \texttt{malloc()}}

\newpage
\section{Listes chaînées}
\begin{tikzpicture}[list/.style={
      rectangle split,
      rectangle split parts=2,
      draw,
      rectangle split horizontal
    },
    >=stealth,
    start chain]

  \node[list,on chain] (A) {12};
  \node[list,on chain] (B) {99};
  \node[list,on chain] (C) {37};
  \node[on chain,draw,inner sep=6pt] (D) {};
  \draw (D.north east) -- (D.south west);
  \draw (D.north west) -- (D.south east);
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
\end{tikzpicture}

\subsection{Création d'un nouveau n\oe{}ud}
\subsection{Insertion d'un n\oe{}ud dans une liste chaînée}
\subsection{Suppression d'un n\oe{}ud d'une liste chaînée}
\subsection{Affichage d'une liste chaînée}

\newpage
\section{Énoncé}

\newpage
\section{Programme}
\subsection{Mode d'emploi}

\newpage
\section{Code}
\subsection{Structures}

\begin{lstlisting}
  typedef struct personne
  {
    int id;
    char nom[25];
    char prenom[25];
    int formateur;
    int nb_formations;
    int formations[30];
    int nb_jours_indisponible;
    int jours_indisponible[7];
    int reduction;
    int val_reduction;
  } personne;
\end{lstlisting}

\begin{lstlisting}
  typedef struct noeud_db_personne
  {
    personne *p;
    struct noeud_db_personne *next;
  } noeud_db_personne;
\end{lstlisting}

\begin{lstlisting}
  typedef struct db_personne
  {
    noeud_db_personne *head;
  } db_personne;
\end{lstlisting}

\begin{lstlisting}
  typedef struct noeud_formation
  {
    personne *p;
    struct noeud_formation *next;
  } noeud_formation;
\end{lstlisting}

\begin{lstlisting}
  typedef struct formation
  {
    int id;
    char nom[40];
    float prix;
    int nb_jours;
    int jours[7];
    float heures[24];
    float durees[10];
    int nb_prerequis;
    int prerequis[10];
    noeud_formation *head;
  } formation;
\end{lstlisting}

\begin{lstlisting}
  typedef struct noeud_db_formation
  {
    formation *f;
    struct noeud_db_formation *next;
  } noeud_db_formation;
\end{lstlisting}

\begin{lstlisting}
  typedef struct db_formation
  {
    noeud_db_formation *head;
  } db_formation;
\end{lstlisting}

\newpage
\subsection{Fonctions}

\begin{lstlisting}
  personne *creer_personne( char nom[], char prenom[], int formateur );
\end{lstlisting}

\begin{lstlisting}
  void afficher_personne( personne *p );
\end{lstlisting}

\begin{lstlisting}
  db_personne *creer_db_personne();
\end{lstlisting}

\begin{lstlisting}
  void ajouter_db_personne( db_personne *db, personne *p );
\end{lstlisting}

\begin{lstlisting}
  int supprimer_db_personne( db_personne *dbp, int id );
\end{lstlisting}

\begin{lstlisting}
  void afficher_db_personne( db_personne *db );
\end{lstlisting}

\begin{lstlisting}
  personne *get_personne( db_personne *db, char nom[], char prenom[], int formateur );
\end{lstlisting}

\begin{lstlisting}
  formation *creer_formation( char nom[], float prix );
\end{lstlisting}

\begin{lstlisting}
  int ajouter_formation( formation *f, personne *p );
\end{lstlisting}

\begin{lstlisting}
  int supprimer_personne_de_formation( formation *f, int id );
\end{lstlisting}

\begin{lstlisting}
  void afficher_formation( formation *f );
\end{lstlisting}

\begin{lstlisting}
  db_formation *creer_db_formation();
\end{lstlisting}

\begin{lstlisting}
  void ajouter_db_formation( db_formation *db, formation *f );
\end{lstlisting}

\begin{lstlisting}
  int supprimer_db_formation( db_formation *dbf, int id );
\end{lstlisting}

\begin{lstlisting}
  formation *get_formation( db_formation *dbf, char nom_formation[] );
\end{lstlisting}

\begin{lstlisting}
  void afficher_db_formation( db_formation *dbf );
\end{lstlisting}

\begin{lstlisting}
  void menu_creer_formation( db_formation *f );
\end{lstlisting}

\begin{lstlisting}
  void menu_creer_personne( db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  int menu_creer( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  void menu_ajouter_formation( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  void menu_supprimer_personne( db_formation *dbf, db_personne *dbp );
\end{lstlisting}

\begin{lstlisting}
  void menu_supprimer_formation( db_formation *dbf, db_personne *dbp );
\end{lstlisting}

\begin{lstlisting}
  int menu_supprimer_personne_de_formation( db_formation *dbf );
\end{lstlisting}

\begin{lstlisting}
  int menu_supprimer( db_formation *dbf, db_personne *dbp );
\end{lstlisting}

\begin{lstlisting}
  int menu_affichage( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  int menu( db_formation *f, db_personne *p );
\end{lstlisting}

\begin{lstlisting}
  int main( void );
\end{lstlisting}

\newpage
\printglossary

\end{document}
